# -*- comment-start: "#" -*-

#include lib/utils.nako3
#end_include

定数 予約語一覧は[
    "func",
    "var", "set", "call", "return", "call_set",
    "while", "case", "when",
    "_cmt", "_debug"
]

定数 記号一覧は[
    "==", "!=",
     "(", ")", 波カッコ, "}", ";", "=", ",", "+", "*"
]

# --------------------------------

●（種類、文字列、行番号）トークン出力とは
    「[{行番号}, "{種類}", "{文字列}"]」を表示
ここまで

●（残り）識別子長とは
    残りを「/^([_a-z][_a-z0-9]*)/」で正規表現マッチ。
    もし、それがnullならば
        0を戻す
    違えば
        抽出文字列[0]の文字数を戻す
    ここまで
ここまで

●（残り）整数長とは
    残りを「/^(-?[1-9][0-9]*|0)/」で正規表現マッチ。
    もし、それがnullならば
        0を戻す
    違えば
        抽出文字列[0]の文字数を戻す
    ここまで
ここまで

●（残り）記号長とは
    もし(0 <= （記号一覧からLEFT(残り, 2)を配列検索）)ならば
        2を戻す
    違えば、もし(0 <= （記号一覧からLEFT(残り, 1)を配列検索）)ならば
        1を戻す
    違えば
        0を戻す
    ここまで
ここまで

●（文字列の）予約語判定とは
    予約語一覧から文字列を配列検索して結果に代入
    （0 <= 結果）を戻す
ここまで

●（文字列から）文字列値抽出とは
    RIGHT（文字列, ((文字列の文字数) - 1)）して残りに代入
    終了位置は(CHR(34)が残りの何文字目か)
    LEFT(残り、終了位置 - 1)を戻す
ここまで

# --------------------------------

標準入力全部読んでソースに代入

行番号は1

ソース文字数はソースの文字数
位置は0
位置が（ソース文字数 - 1）以下の間繰り返す
    文字取得（ソース、位置）して文字に代入
    RIGHT（ソース, (ソース文字数 - 位置)）して残りに代入

    もし LEFT(残り, 1) が" "ならば
        # スキップ
        位置 = 位置 + 1
    違えば、もし LEFT(残り, 1) がLFならば
        # スキップ
        位置 = 位置 + 1
        行番号 = 行番号 + 1
    違えば、もし(LEFT(残り, 1)  = CHR(34))ならば
        残りから文字列値抽出して値に代入
        トークン出力（"str", 値, 行番号）
        位置 = 位置 + (値の文字数) + 2
    違えば、もし 0＜記号長（残り）ならば
        文字列 = LEFT（残り、記号長(残り)）
        トークン出力（"sym", 文字列, 行番号）
        位置 = 位置 + (文字列の文字数)
    違えば、もし 0＜整数長（残り）ならば
        文字列 = LEFT（残り、整数長(残り)）
        トークン出力（"int", 文字列, 行番号）
        位置 = 位置 + (文字列の文字数)
    違えば、もし LEFT(残り, 2) が"//"ならば
        スキップ文字数はLFが残りの何文字目か
        位置 = 位置 + スキップ文字数
    違えば、もし 0＜識別子長(残り)ならば
        文字列 = LEFT（残り、識別子長(残り)）
        種類は「」
        もし（文字列の予約語判定）が真ならば
            種類は「kw」
        違えば
            種類は「ident」
        ここまで
        トークン出力（種類, 文字列, 行番号）
        位置 = 位置 + (文字列の文字数)
    違えば
        「想定外のパターン: 行（{行番号}） ({文字})」で異常終了
    ここまで
ここまで
